---
title: "Task"
author: "Yevheniia Zhernova"
date: "28/10/2025"
format:
  html:
    embed-resources: true
editor: source
---

## Question 1 Atomic Types
Question description

Create the following variables related to your chosen object:
- 4 numeric values (e.g., population, temperature, size, rating)  
- 3 integer values (e.g., number of moons, buildings, inhabitants)  
- 2 logical values (e.g., has_water, is_inhabited)  
- 3 character values (e.g., name, region, category)

```{r}
# numeric values
distance_to_bratislava_km <- 16.3    # km (approx.)
elevation_m <- 130                 # meters (approx.)
area <- 14.5                  # <-- теперь создаётся
avg_density <- 620                 # numeric,



# code for solving task
# integer
population <- 9000L
num_parks <- 5L
num_schools <- 3L

#character
name <- "Bernolákovo"
old_name <- "Cseklész"
region <- "Bratislavský kraj"
category <- "Obec"  

# logical
has_water <- TRUE
is_inhabited <- TRUE
```

## Question 2 Vectors

Question description
Create three different vectors:

```{r}
# code for solving task
# 1. Numeric vector
numeric_vector <- c(population, area)
numeric_vector
# [1] 9000.0   14.5

# 2. Sequence vector (from 20 to 100 step 5)
sequence_vector <- seq(from = 20, to = 100, by = 5)
sequence_vector
# [1] 20 25 30 ... 100

# 3. Logical vector of 10 random TRUE/FALSE 
set.seed(123)  # for repeating result
logical_vector <- sample(c(TRUE, FALSE), size = 10, replace = TRUE)
logical_vector
```

## Question 3 Matrix

```{r}
set.seed(42)  # for reproducibility

# 3×3 matrix with random integers between -50 and 50
m <- matrix(
sample(-50:50, size = 9, replace = TRUE),
nrow = 3, ncol = 3, byrow = TRUE)

# Name rows/columns (Bernolákovo theme)
rownames(m) <- c("Centrum", "Juhozápad", "Sever")
colnames(m) <- c("Doprava", "Zeleň", "Voda")

# Show matrix
m

# Row and column means
row_avgs <- rowMeans(m)
col_avgs <- colMeans(m)

row_avgs
col_avgs
```

## Question 4 List

```{r}
bernolakovolist <- list(
  description = "Bernolákovo mini-universe: basic facts, vectors for practice, and a themed matrix with stats.",
  
  scalars = list(
population   = population,
  area         = area,
has_water    = has_water,
    is_inhabited = is_inhabited,
    name         = name,
old_name     = old_name,
    region       = region,
 category     = category),
  
  vectors = list(
numeric  = numeric_vector,
  sequence = sequence_vector,
logical  = logical_vector ),
  
  matrix = m,
  
  matrix_stats = list(
     row_means = row_avgs,
col_means = col_avgs))


str(bernolakovolist)
```

## Question 5 Factor

```{r}
development_level <- factor(
  c("medium", "high", "medium", "low", "high", "medium", "low"),
  levels = c("low", "medium", "high"), ordered = TRUE
)

# Check counts
table(development_level)
```

## Question 6 Data Frame

```{r}
bern_df <- data.frame(
  district = c("Centrum", "Juhozápad", "Sever", "Východ", "Záhrady", "Pri Jazere"),
  pop      = c(1800, 1200, 950, 1100, 700, 450),              # numeric
  has_playground = c(TRUE, TRUE, FALSE, TRUE, FALSE, TRUE),   # logical
  zone = factor(c("mixed", "residential", "residential",  "industrial", "residential", "recreational"),
  levels = c("residential", "mixed", "industrial", "recreational")),
  dist_km  = c(0.2, 1.4, 1.1, 2.3, 1.8, 2.7)                  # numeric
)

# Inspect
str(bern_df)
summary(bern_df)

# Add a derived column (example rule)
bern_df$priority <- with(
  bern_df,
  ifelse(pop > 1000 & !has_playground, "high",
         ifelse(pop > 1000, "medium", "low"))
)
bern_df$priority <- factor(bern_df$priority, levels = c("low", "medium", "high"), ordered = TRUE)

# Quick checks
table(bern_df$zone)
table(bern_df$priority)
bern_df

```

```{r}
## --- Write to files ---
write.csv(bern_df, "bernolakovo_df.csv", row.names = FALSE)   # CSV
saveRDS(bern_df, "bernolakovo_df.rds")                        # keeps factors/attributes

```

### 2.1. Querying Vectors

```{r}
# ---- Setup: ensure Task 1 objects exist ----
if (!exists("sequence_vector")) sequence_vector <- seq(20, 100, by = 5)
if (!exists("logical_vector"))  { set.seed(123); logical_vector <- sample(c(TRUE, FALSE), 10, TRUE) }
if (!exists("m")) {
set.seed(42)### 2.1. Querying Vectors
m <- matrix(sample(-50:50, 9, replace = TRUE), nrow = 3, byrow = TRUE)
rownames(m) <- c("Centrum", "Juhozápad", "Sever")
colnames(m) <- c("Doprava", "Zeleň", "Voda")
}
if (!exists("your_df")) {
your_df <- data.frame(
name         = c("Bernolákovo","Ivanka pri Dunaji","Senec","Tomášov","Malinovo"),
region       = c("Bratislavský kraj","Bratislavský kraj","Bratislavský kraj","Bratislavský kraj","Bratislavský kraj"),
category     = c("Obec","Obec","Mesto","Obec","Obec"),
population   = c(9000L, 6800L, 21000L, 3800L, 4300L),
area_km2     = c(14.5, 18.1, 38.6, 19.7, 10.2),
is_inhabited = c(TRUE, TRUE, TRUE, TRUE, TRUE),
has_water    = c(TRUE, TRUE, TRUE, FALSE, TRUE),
stringsAsFactors = FALSE
)
}
```

2.1.1. From your Sequence vector (the one with all your numbers):
# ---- 2.1.1 Sequence vector ----

```{r}
# ---- 2.1.1 Sequence vector ----
sequence_vector[3]
sequence_vector[2:5]
sequence_vector[sequence_vector > 20]
```

2.1.2. From your Logical vector:

# ---- 2.1.2 Logical vector ----

```{r}
# ---- 2.1.2 Logical vector ----
logical_vector[logical_vector]
which(logical_vector)
```

### 2.2. Querying Your "Universe" List

```{r}
my_universe <- list(
description = "Mini-universe of Bernolákovo and surroundings.",
matrix3x3   = m,
vec         = sequence_vector
)

# access description via $

my_universe$description

# access 3x3 matrix via [[ ]]

my_universe[["matrix3x3"]]

# access the second element of inner vector

my_universe[["vec"]][2]
```

### 2.3. Investigating Your Data Frame

```{r}
# first 3 rows

head(your_df, 3)

# value from 4th row, 1st column

your_df[4, 1]

# logical column as a vector

your_df$is_inhabited

# Logical subsetting (example condition)

df_subset <- your_df[your_df$population > 5000, ]
df_subset

# %in% subsetting (two categories from a column)

df_subset_2 <- your_df[your_df$region %in% c("Bratislavský kraj","Trnavský kraj"), ]
df_subset_2
```

### 2.4. Handling "Corrupted" Data (`NA`)

```{r}
df_corrupted <- your_df

# introduce 3 NAs

df_corrupted[2, "area_km2"]   <- NA
df_corrupted[5, "population"] <- NA
df_corrupted[3, "has_water"]  <- NA

# total number of NAs

sum(is.na(df_corrupted))

# number of NAs per column

colSums(is.na(df_corrupted))

# mean with and without na.rm (numeric column with NA)

mean(df_corrupted$population)                # NA
mean(df_corrupted$population, na.rm = TRUE)  # cleaned mean

# clean data frame with complete cases only

df_clean <- na.omit(df_corrupted)
df_clean
```

### 2.5. Bonus Challenge: `which()`

```{r}
# index of max in a numeric column

idx_max_pop <- which.max(your_df$population)
your_df[idx_max_pop, ]

# index of min in another numeric column

idx_min_area <- which.min(your_df$area_km2)
your_df[idx_min_area, ]
```